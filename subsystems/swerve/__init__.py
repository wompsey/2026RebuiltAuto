"""
Contains the drivetrain, built off CTRE's Swerve Project Generator.
"""

import math
from typing import Callable, overload

from commands2 import Command, Subsystem
from commands2.sysid import SysIdRoutine
from pathplannerlib.auto import AutoBuilder
from pathplannerlib.config import RobotConfig, PIDConstants
from pathplannerlib.controller import PPHolonomicDriveController
from pathplannerlib.util import DriveFeedforwards
from pathplannerlib.util.swerve import SwerveSetpoint, SwerveSetpointGenerator
from phoenix6 import SignalLogger, swerve, units, utils
from phoenix6.swerve.requests import ApplyRobotSpeeds, FieldCentric, RobotCentric
from pykit.logger import Logger
from wpilib import DriverStation, Notifier, RobotController
from wpilib.sysid import SysIdRoutineLog
from wpimath.geometry import Pose2d, Rotation2d, Pose3d, Twist3d
from wpimath.kinematics import ChassisSpeeds
from wpimath.units import degreesToRadians, inchesToMeters, rotationsToRadians

# Robot config
from robot_config import currentRobot, Robot
if currentRobot == Robot.LARRY:
    from generated.larry.tuner_constants import TunerSwerveDrivetrain
else:
    from generated.tuner_constants import TunerSwerveDrivetrain


class SwerveSubsystem(Subsystem, swerve.SwerveDrivetrain):
    """
    Class that extends the Phoenix 6 SwerveDrivetrain class and implements
    Subsystem so it can easily be used in command-based projects.

    Generated by the 2026 Tuner X Swerve Project Generator
    https://v6.docs.ctr-electronics.com/en/stable/docs/tuner/tuner-swerve/index.html
    """

    _SIM_LOOP_PERIOD: units.second = 0.004  # 4 ms

    _BLUE_ALLIANCE_PERSPECTIVE_ROTATION = Rotation2d.fromDegrees(0)
    """Blue alliance sees forward as 0 degrees (toward red alliance wall)"""
    _RED_ALLIANCE_PERSPECTIVE_ROTATION = Rotation2d.fromDegrees(180)
    """Red alliance sees forward as 180 degrees (toward blue alliance wall)"""

    @overload
    def __init__(
        self,
        drivetrain_constants: swerve.SwerveDrivetrainConstants,
        modules: list[swerve.SwerveModuleConstants],
        /,
    ) -> None:
        """
        Constructs a CTRE SwerveDrivetrain using the specified constants.

        This constructs the underlying hardware devices, so users should not construct
        the devices themselves. If they need the devices, they can access them through
        getters in the classes.

        :param drivetrain_constants: Drivetrain-wide constants for the swerve drive
        :type drivetrain_constants:  swerve.SwerveDrivetrainConstants
        :param modules:              Constants for each specific module
        :type modules:               list[swerve.SwerveModuleConstants]
        """

    @overload
    def __init__(
        self,
        drivetrain_constants: swerve.SwerveDrivetrainConstants,
        odometry_update_frequency: units.hertz,
        modules: list[swerve.SwerveModuleConstants],
        /,
    ) -> None:
        """
        Constructs a CTRE SwerveDrivetrain using the specified constants.

        This constructs the underlying hardware devices, so users should not construct
        the devices themselves. If they need the devices, they can access them through
        getters in the classes.

        :param drivetrain_constants:        Drivetrain-wide constants for the swerve drive
        :type drivetrain_constants:         swerve.SwerveDrivetrainConstants
        :param odometry_update_frequency:   The frequency to run the odometry loop. If
                                            unspecified or set to 0 Hz, this is 250 Hz on
                                            CAN FD, and 100 Hz on CAN 2.0.
        :type odometry_update_frequency:    units.hertz
        :param modules:                     Constants for each specific module
        :type modules:                      list[swerve.SwerveModuleConstants]
        """

    @overload
    def __init__(
        self,
        drivetrain_constants: swerve.SwerveDrivetrainConstants,
        odometry_update_frequency: units.hertz,
        odometry_standard_deviation: tuple[float, float, float],
        vision_standard_deviation: tuple[float, float, float],
        modules: list[swerve.SwerveModuleConstants],
        /,
    ) -> None:
        """
        Constructs a CTRE SwerveDrivetrain using the specified constants.

        This constructs the underlying hardware devices, so users should not construct
        the devices themselves. If they need the devices, they can access them through
        getters in the classes.

        :param drivetrain_constants:        Drivetrain-wide constants for the swerve drive
        :type drivetrain_constants:         swerve.SwerveDrivetrainConstants
        :param odometry_update_frequency:   The frequency to run the odometry loop. If
                                            unspecified or set to 0 Hz, this is 250 Hz on
                                            CAN FD, and 100 Hz on CAN 2.0.
        :type odometry_update_frequency:    units.hertz
        :param odometry_standard_deviation: The standard deviation for odometry calculation
                                            in the form [x, y, theta]ᵀ, with units in meters
                                            and radians
        :type odometry_standard_deviation:  tuple[float, float, float]
        :param vision_standard_deviation:   The standard deviation for vision calculation
                                            in the form [x, y, theta]ᵀ, with units in meters
                                            and radians
        :type vision_standard_deviation:    tuple[float, float, float]
        :param modules:                     Constants for each specific module
        :type modules:                      list[swerve.SwerveModuleConstants]
        """

    @overload
    def __init__(
        self,
        drivetrain_constants: swerve.SwerveDrivetrainConstants,
        arg0: None,
        arg1: None,
        arg2: None,
        arg3: None,
        /,
    ) -> None: ...

    def __init__(
        self,
        drivetrain_constants: swerve.SwerveDrivetrainConstants,
        arg0=None,
        arg1=None,
        arg2=None,
        arg3=None,
    ):
        Subsystem.__init__(self)
        TunerSwerveDrivetrain.__init__(
            self, drivetrain_constants, arg0, arg1, arg2, arg3
        )

        self._sim_notifier: Notifier | None = None
        self._last_sim_time: units.second = 0.0

        self._has_applied_operator_perspective = False
        """Keep track if we've ever applied the operator perspective before or not"""

        # Swerve requests to apply during SysId characterization
        self._translation_characterization = swerve.requests.SysIdSwerveTranslation()
        self._steer_characterization = swerve.requests.SysIdSwerveSteerGains()
        self._rotation_characterization = swerve.requests.SysIdSwerveRotation()

        self._sys_id_routine_translation = SysIdRoutine(
            SysIdRoutine.Config(
                # Use default ramp rate (1 V/s) and timeout (10 s)
                # Reduce dynamic voltage to 4 V to prevent brownout
                stepVoltage=4.0,
                # Log state with SignalLogger class
                recordState=lambda recordState: SignalLogger.write_string(
                    "SysIdTranslation_State", SysIdRoutineLog.stateEnumToString(recordState)
                ) and None,
            ),
            SysIdRoutine.Mechanism(
                lambda output: self.set_control(
                    self._translation_characterization.with_volts(output)
                ),
                lambda log: None,
                self,
            ),
        )
        """
        SysId routine for characterizing translation. 
        This is used to find PID gains for the drive motors.
        """

        self._sys_id_routine_steer = SysIdRoutine(
            SysIdRoutine.Config(
                # Use default ramp rate (1 V/s) and timeout (10 s)
                # Use dynamic voltage of 7 V
                stepVoltage=7.0,
                # Log state with SignalLogger class
                recordState=lambda recordState: SignalLogger.write_string(
                    "SysIdSteer_State", SysIdRoutineLog.stateEnumToString(recordState)
                ) and None,
            ),
            SysIdRoutine.Mechanism(
                lambda output: self.set_control(
                    self._steer_characterization.with_volts(output)
                ),
                lambda log: None,
                self,
            ),
        )
        """
        SysId routine for characterizing steer. 
        This is used to find PID gains for the steer motors.
        """

        self._sys_id_routine_rotation = SysIdRoutine(
            SysIdRoutine.Config(
                # This is in radians per second², but SysId only supports "volts per second"
                rampRate=math.pi / 6,
                # Use dynamic voltage of 7 V
                stepVoltage=7.0,
                # Use default timeout (10 s)
                # Log state with SignalLogger class
                recordState=lambda recordState: SignalLogger.write_string(
                    "SysIdSteer_State", SysIdRoutineLog.stateEnumToString(recordState)
                ) and None,
            ),
            SysIdRoutine.Mechanism(
                lambda output: (
                    # output is actually radians per second, but SysId only supports "volts"
                    self.set_control(
                        self._rotation_characterization.with_rotational_rate(output)
                    ),
                    # also log the requested output for SysId
                    SignalLogger.write_double("Rotational_Rate", output),
                )
                and None,
                lambda log: None,
                self,
            ),
        )
        """
        SysId routine for characterizing rotation.
        This is used to find PID gains for the FieldCentricFacingAngle HeadingController.
        See the documentation of swerve.requests.SysIdSwerveRotation for info on importing 
            the log to SysId.
        """

        self._sys_id_routine_to_apply = self._sys_id_routine_translation
        """The SysId routine to test"""

        # Create config from GUI settings
        config = RobotConfig.fromGUISettings()
        self._apply_robot_speeds = ApplyRobotSpeeds()
        AutoBuilder.configure(
            lambda: self.get_state().pose,  # Supplier of current robot pose
            self.reset_pose,  # Consumer for seeding pose against auto
            lambda: self.get_state().speeds,  # Supplier of current robot speeds
            # Consumer of ChassisSpeeds and feedforwards to drive the robot
            lambda speeds, feedforwards: self._apply_request_internal(
                self._apply_robot_speeds
                .with_speeds(speeds)
                .with_wheel_force_feedforwards_x(feedforwards.robotRelativeForcesXNewtons)
                .with_wheel_force_feedforwards_y(feedforwards.robotRelativeForcesYNewtons)
            ),
            PPHolonomicDriveController(
                PIDConstants(2.75, 0.0, 0.0),
                PIDConstants(2.75, 0.0, 0.0)
            ),
            config,
            lambda: DriverStation.getAlliance() == DriverStation.Alliance.kRed,
            self
        )

        # State logging
        state = self.get_state()
        self._cached_pose = state.pose
        self._cached_speeds = state.speeds
        self._cached_module_states = state.module_states
        self._cached_module_targets = state.module_targets
        self._generator_active = False
        Logger.recordOutput("Drive/GeneratorActive", self._generator_active)

        # Setpoint generator
        self._generator_master_switch = False
        self._previous_setpoint = SwerveSetpoint(
            self._cached_speeds,
            self._cached_module_states,
            DriveFeedforwards.zeros(4)
        )
        self._setpoint_generator = SwerveSetpointGenerator(config, rotationsToRadians(3.75))

        if utils.is_simulation():
            self._start_sim_thread()

    def _apply_request_internal(self, req: swerve.requests.SwerveRequest):
        """
        Applies the SwerveSetpointGenerator onto given SwerveRequests.

        If the request has velocity x and y attributes and a rotational_rate,
        it's a "normal" request (FieldCentric, RobotCentric, etc).
        If it's specifically FieldCentric, convert to robot speeds
            before passing it into the SwerveSetpointGenerator.

        Elif the request has a "speeds" attribute (ApplyRobotSpeeds),
            pass speeds straight into the gen.

        Otherwise, the request is used for something else (hockey stop, PointAtX, etc).
        Simply update prevSetpoint and call the request as normal.
        """
        if isinstance(req, (RobotCentric, FieldCentric)) and self._generator_master_switch:
            target_speeds = ChassisSpeeds(
                req.velocity_x,
                req.velocity_y,
                req.rotational_rate,
            )

            # Convert field speeds to robot relative
            if isinstance(req, FieldCentric):
                target_speeds = ChassisSpeeds.fromFieldRelativeSpeeds(
                    req.velocity_x,
                    req.velocity_y,
                    req.rotational_rate,
                    self._cached_pose.rotation() + self.get_operator_forward_direction(),
                )


            self._previous_setpoint = self._setpoint_generator.generateSetpoint(
                self._previous_setpoint,
                target_speeds,
                0.02,
            )

            self._generator_active = True
            self.set_control(
                self._apply_robot_speeds
                .with_speeds(self._previous_setpoint.robot_relative_speeds)
                .with_wheel_force_feedforwards_x(
                    self._previous_setpoint.feedforwards.robotRelativeForcesXNewtons
                )
                .with_wheel_force_feedforwards_y(
                    self._previous_setpoint.feedforwards.robotRelativeForcesYNewtons
                )
            )

        elif isinstance(req, ApplyRobotSpeeds) and self._generator_master_switch:
            self._previous_setpoint = self._setpoint_generator.generateSetpoint(
                self._previous_setpoint,
                req.speeds,
                0.02,
            )

            self._generator_active = True
            self.set_control(
                self._apply_robot_speeds
                .with_speeds(self._previous_setpoint.robot_relative_speeds)
            )

        # Everything else
        else:
            self._previous_setpoint = SwerveSetpoint(
                self._cached_speeds,
                self._cached_module_states,
                DriveFeedforwards.zeros(4),
            )

            self._generator_active = False
            self.set_control(req)

    def apply_request(
        self, request: Callable[[], swerve.requests.SwerveRequest]
    ) -> Command:
        """
        Returns a command that applies the specified control request to this swerve drivetrain.

        If the specific control request controls robot movement, it will automatically be passed
        through PathPlanner's SwerveSetpointGenerator.

        :param request: Lambda returning the request to apply
        :type request: Callable[[], swerve.requests.SwerveRequest]
        :returns: Command to run
        :rtype: Command
        """
        return self.run(lambda: self._apply_request_internal(request()))

    def sys_id_quasistatic(self, direction: SysIdRoutine.Direction) -> Command:
        """
        Runs the SysId Quasistatic test in the given direction for the routine
        specified by self.sys_id_routine_to_apply.

        :param direction: Direction of the SysId Quasistatic test
        :type direction: SysIdRoutine.Direction
        :returns: Command to run
        :rtype: Command
        """
        return self._sys_id_routine_to_apply.quasistatic(direction)

    def sys_id_dynamic(self, direction: SysIdRoutine.Direction) -> Command:
        """
        Runs the SysId Dynamic test in the given direction for the routine
        specified by self.sys_id_routine_to_apply.

        :param direction: Direction of the SysId Dynamic test
        :type direction: SysIdRoutine.Direction
        :returns: Command to run
        :rtype: Command
        """
        return self._sys_id_routine_to_apply.dynamic(direction)

    def periodic(self):
        # Periodically try to apply the operator perspective.
        # If we haven't applied the operator perspective before,
        #   then we should apply it regardless of DS state.
        # This allows us to correct the perspective in case the robot code restarts
        #   mid-match.
        # Otherwise, only check and apply the operator perspective if the DS is disabled.
        # This ensures driving behavior doesn't change
        #   until an explicit disable event occurs during testing.
        if not self._has_applied_operator_perspective or DriverStation.isDisabled():
            alliance_color = DriverStation.getAlliance()
            if alliance_color is not None:
                self.set_operator_perspective_forward(
                    self._RED_ALLIANCE_PERSPECTIVE_ROTATION
                    if alliance_color == DriverStation.Alliance.kRed
                    else self._BLUE_ALLIANCE_PERSPECTIVE_ROTATION
                )
                self._has_applied_operator_perspective = True

        # Update caches
        state = self.get_state()
        self._cached_pose = state.pose
        self._cached_speeds = state.speeds
        self._cached_module_states = state.module_states
        self._cached_module_targets = state.module_targets
        Logger.recordOutput("Drive/OdometryFrequency", self.get_odometry_frequency())
        Logger.recordOutput("Drive/Speeds", self._cached_speeds)
        Logger.recordOutput("Drive/ModuleStates", self._cached_module_states)
        Logger.recordOutput("Drive/ModuleTargets", self._cached_module_targets)

        Logger.recordOutput("Drive/EstimatedPosition2d", self._cached_pose)

        # Calculate 3D pose based off gyro's reported rotation
        rotation = self.get_rotation3d()
        Logger.recordOutput(
            "Drive/EstimatedPosition3d", Pose3d(self._cached_pose).exp(
                Twist3d(
                    0,
                    0,
                    abs(degreesToRadians(rotation.x_degrees)) * inchesToMeters(12) / 2,
                    0,
                    degreesToRadians(rotation.x_degrees),
                    0
                )
            ).exp(
                Twist3d(
                    0,
                    0,
                    abs(degreesToRadians(rotation.z_degrees)) * inchesToMeters(12) / 2,
                    degreesToRadians(rotation.z_degrees),
                    0,
                    0
                )
            )
        )

        Logger.recordOutput("Drive/GeneratorActive", self._generator_active)

    def _start_sim_thread(self):
        def _sim_periodic():
            current_time = utils.get_current_time_seconds()
            delta_time = current_time - self._last_sim_time
            self._last_sim_time = current_time

            # use the measured time delta, get battery voltage from WPILib
            self.update_sim_state(delta_time, RobotController.getBatteryVoltage())

        # Run simulation at a faster rate so PID gains behave more reasonably
        self._last_sim_time = utils.get_current_time_seconds()
        self._sim_notifier = Notifier(_sim_periodic)
        self._sim_notifier.startPeriodic(self._SIM_LOOP_PERIOD)

    def add_vision_measurement(
        self,
        vision_robot_pose: Pose2d,
        timestamp: units.second,
        vision_measurement_std_devs: tuple[float, float, float] | None = None,
    ):
        """
        Adds a vision measurement to the Kalman Filter. This will correct the
        odometry pose estimate while still accounting for measurement noise.

        Note that the vision measurement standard deviations passed into this method
        will continue to apply to future measurements until a subsequent call to
        set_vision_measurement_std_devs or this method.

        :param vision_robot_pose:           The pose of the robot as measured by the vision camera.
        :type vision_robot_pose:            Pose2d
        :param timestamp:                   The timestamp of the vision measurement in seconds.
        :type timestamp:                    second
        :param vision_measurement_std_devs: Standard deviations of the vision pose measurement
                                            in the form [x, y, theta]ᵀ, with units in meters
                                            and radians.
        :type vision_measurement_std_devs:  tuple[float, float, float] | None
        """
        TunerSwerveDrivetrain.add_vision_measurement(
            self,
            vision_robot_pose,
            utils.fpga_to_current_time(timestamp),
            vision_measurement_std_devs
        )

    def sample_pose_at(self, timestamp: units.second) -> Pose2d | None:
        """
        Return the pose at a given timestamp, if the buffer is not empty.

        :param timestamp: The timestamp of the pose in seconds.
        :type timestamp: second
        :returns: The pose at the given timestamp (or None if the buffer is empty).
        :rtype: Pose2d | None
        """
        return TunerSwerveDrivetrain.sample_pose_at(self, utils.fpga_to_current_time(timestamp))
